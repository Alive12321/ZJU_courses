 

![img](file:///C:\Users\臧可\AppData\Local\Temp\ksohtml2944\wps1.jpg) 

**浙江大学实验报告**

 

课程名称：  计算机体系结构          实验类型： 综合    

实验项目名称：实验 2 - 流水线 CPU 设计（准备）：流水加法机                      

学生姓名：臧可        专业：计算机科学与技术      学号：3180102095           

同组学生姓名： None            指导老师：常瑞     

实验地点：曹光彪西楼301                 实验日期：  2020年   10月  28日

 

## 一、 实验目的和要求

### 1.1 实验目的

- 理解流水线的基本概念与思想。

- 基于在单周期/多周期 CPU 中已经实现的模块，实现 5 级流水线框架。

- 理解流水线设计在提高 CPU 的吞吐率、提升整体性能上的作用与优越性。

### 1.2 实验要求

在本次实验中，仅要求实现 **addi** 和 **nop** 指令，lab2.s 正常运行，仿真结果正确。本实验提供参考设计图（控制信号及其他必要的模块接口需自己设计添加，该设计图仅起提示模块逻辑关联的作用），见下图。鼓励自主设计 CPU 结构，但请给出如此设计的理由。

本次实验的主要目的在于建立起大家对于流水线的概念，后期将在此基础上对 CPU 的功能进行扩展，有余力的同学可提前完成 **ALU** **和译码器**功能的扩展（扩展指令的基本要求：MIPS 参照计算机组成 Lab12，RV 参考 RV32I）。

为便于后续实验当中（可能出现的）对结构的修改，请尽可能对各功能模块做好封装；但是请不要封装流水级（例如 Module EX），因为在后续优化中可能会经历流水级的拆分和重组。

![image-20201028081933467](体系Lab2.assets/image-20201028081933467.png)

## 二、 主要实验工具

- **HDL**：Verilog

- **IDE**：ISE

- **开发板**：Sword 4

## 三、实验内容和原理

### 3.1 流水线与单周期/多周期 CPU 设计对比

与多周期 CPU 不同，在同一时刻下，流水线的五个流水级运行的指令实际各不相同，如果再像多周期 CPU 中使用状态机调度控制信号，状态机本身将会非常复杂，这对于电路设计也是非常不利的。因此，我们一般**将一条指令所需的控制信号一起存在流水段间寄存器中，随**

**指令其他信息一起顺着流水线传递。**

原则上每一拍过后，流水线都会向前流动一段，例如第 x 拍，EX 段内指令 lw 完成地址计算，下一拍（第 x+1 拍）lw 进入 mem 段完成访存，因而，一般而言段内任务需要当拍完成，在使用段间寄存器以外的寄存器时，可能产生的时序问题请务必注意。

其他关于单周期、多周期、流水线 CPU 的特点对比如表 1 所示，请在认真理解三者的区别之后再进行实验。

![image-20201028080807885](体系Lab2.assets/image-20201028080807885.png)

### 3.2 流水级划分

流水级划分的一般经验准则：

1. **按功能划分**。不同的功能最好属于不同的流水级，因为一般情况下，<u>单个流水级功能越少，组合逻辑越简单，延迟越低，时钟频率越高</u>。

2. **按时间划分**。在有些组件中（例如译码器），可能会出现较长连续的组合电路；它们往往会成为系统性能的瓶颈，但<u>拆分组合电路、在中间插入阶段寄存器，并不会对电路的功能造成影响</u>。而由于流水线时钟频率取决于最长段，一般情况下，<u>阶段越平均，CPU的整体利用率越高，性能越高</u>。

3. **按空间划分**。空间上远离的组件应该尽可能属于不同的流水级，<u>使用寄存器隔断往返的长距离通信带来的时间开销</u>。在 FPGA 板上，由于各类硬件资源已经固定而无法任意挪动，按空间划分显得更为重要。

根据经验准则，我们可以构造最基础的 5 段流水线设计（取指、译码、执行、访存、写回）。

在此基础上，我们可以根据实际布线中观察到的时间开销有针对性地进行优化。因此，从软件工程的角度而言，为了尽可能方便以后的修改，请尽可能封装各个功能模块，并设计合适的接口（包括调试接口）。

## 四、 实验过程和数据记录及结果分析

1. 根据参考设计图搭建完整的流水线加法机。框架结构如下图。

![image-20201028082131367](体系Lab2.assets/image-20201028082131367.png)

2. 进行仿真测试，以检验 CPU 基本功能。

![image-20201028203314142](体系Lab2.assets/image-20201028203314142.png)

​	仿真结果显示register4内存储的数据值的变化，与coe相符，正确。

3.  进行上板测试，以检验 CPU 设计规范。

   上板结果与预期相符。部分截图见下图。

![image-20201028203824775](体系Lab2.assets/image-20201028203824775.png)

![image-20201028203834963](体系Lab2.assets/image-20201028203834963.png)

 

## 五、 讨论与心得

### 5.1 思考题

1. ###### 对于 part1（3-15 行），请计算你的 CPU 的 CPI，再用 Lab1 的单周期/多周期 CPU 运行 part1，对比二者的 CPI。

   CPI = CC/Instruction = 16/12 = 1;

   Lab1(单周期) = CC/Instruction = 1;

   单周期的CPI是1，流水线因为要算上进入流水的时间，所以其CPI可以无限接近于1但是大于1。

2. ###### 对于 part2（27-42 行），请计算你的 CPU 的 CPI（假设 nop 不计入指令条数），再用Lab1 的单周期/多周期 CPU 运行 part1，对比二者的 CPI。试解释为何需要添加 nop指令（提示：如果不添加，会导致什么问题？）。

   CPI = CC/Instruction = 16/4 = 4；

   Lab1(单周期) = CC/Instruction = 16/4 = 4;

   因为part2不是刚进入CPU的指令，流水不需要考虑刚进入的时间，和单周期CPU的CPI是一样的。

   因为每一部的指令都和上一步的指令数据相关，如果不添加nop指令等待4个时钟周期，每一条指令中用到的上一条指令中的数据还没有存入，将会产生数据冲突。得到的结果将会是错误的。（正确结果是1,3,6,A;错误结果是1,2,3,4)

3. ###### 果使用 vivado 作为开发工具，截图并给出关键路径报告截图，分析该路径成为延迟关键路径的原因。

   使用的是ISE。

### 5.2 心得

通过本次实验，我对于流水线的框架有了一个基础的了解。通过课后思考题，也对流水线和多周期CPU之间的差别有了更加清晰的认知。